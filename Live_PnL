import streamlit as st
import mysql.connector
import pandas as pd
import time
from datetime import datetime

class BasketExplorer:
    def __init__(self, host, username, password, database):
        self.conn = None
        self.host = host
        self.username = username
        self.password = password
        self.database = database
        self.connect_to_database()

    def connect_to_database(self):
        """Establish database connection with retry logic"""
        max_retries = 3
        retry_delay = 2  # seconds
        
        for attempt in range(max_retries):
            try:
                self.conn = mysql.connector.connect(
                    host=self.host,
                    user=self.username,
                    password=self.password,
                    database=self.database,
                    connect_timeout=5
                )
                return
            except mysql.connector.Error as e:
                if attempt == max_retries - 1:
                    st.error(f"Failed to connect to database after {max_retries} attempts: {e}")
                    raise
                time.sleep(retry_delay)

    def reconnect_if_needed(self):
        """Check connection and reconnect if necessary"""
        try:
            if not self.conn.is_connected():
                self.connect_to_database()
        except Exception as e:
            st.error(f"Connection check failed: {e}")
            self.connect_to_database()

    def fetch_data(self, query):
        """Execute SQL query with error handling"""
        self.reconnect_if_needed()
        
        try:
            if self.conn and self.conn.is_connected():
                return pd.read_sql(query, self.conn)
            else:
                st.error("Database connection is not available.")
                return None
        except Exception as e:
            st.error(f"Error executing query: {e}")
            return None

    def fetch_last_row(self, table_name):
        """Fetch the most recent record from a table"""
        query = f"SELECT * FROM {table_name} ORDER BY VDATE DESC, VTIME DESC LIMIT 1"
        return self.fetch_data(query)

    @staticmethod
    def format_pnl(value):
        """Format PnL value with color coding"""
        color = "green" if value > 0 else "red" if value < 0 else "gray"
        return f'<span style="color:{color}; font-size:24px; font-weight:bold;">{value:,.2f}</span>'

    def process_data(self):
        """Process and organize basket data"""
        try:
            # Fetch basket data
            basket_query = "SELECT * FROM httsbaskets"
            baskets_df = self.fetch_data(basket_query)

            if baskets_df is None or baskets_df.empty:
                st.warning("No basket data found.")
                return None

            # Fetch the last row from PnL HTTS table
            pnl_df = self.fetch_last_row("pnlhtts")
            if pnl_df is None or pnl_df.empty:
                st.warning("No PnL data found.")
                return None

            # Extract VDATE and VTIME for reference
            last_update_date = pnl_df['VDATE'].iloc[0]
            last_update_time = pnl_df['VTIME'].iloc[0]

            # Filter active baskets
            active_baskets = baskets_df[(baskets_df['STATUS'] == '1')]

            def calculate_pnl(basket_name):
                """Calculate PnL for a specific basket"""
                pnl_columns = [col for col in pnl_df.columns if col == basket_name]
                if not pnl_columns:
                    return 0
                return pd.to_numeric(pnl_df[pnl_columns].iloc[0], errors='coerce').fillna(0).sum()

            # Segregate by OWNED and CATEGORY
            live_intra = active_baskets[(active_baskets['CATEGORY'] == 'INTRA')]
            live_daily = active_baskets[(active_baskets['CATEGORY'] == 'DAILY')]
            paper_baskets = active_baskets[active_baskets['OWNED'] == 'PAPER']

            # Calculate PnL for each basket
            def create_pnl_df(basket_group):
                return pd.DataFrame([{
                    "Basket Name": basket['BASKETNAME'],
                    "Category": basket['CATEGORY'],
                    "PnL": calculate_pnl(basket['BASKETNAME'])
                } for _, basket in basket_group.iterrows()])

            intra_df = create_pnl_df(live_intra)
            daily_df = create_pnl_df(live_daily)
            paper_df = create_pnl_df(paper_baskets)

            # Calculate summary metrics
            live_intra_pnl = intra_df["PnL"].sum() if not intra_df.empty else 0
            live_daily_pnl = daily_df["PnL"].sum() if not daily_df.empty else 0
            total_live_pnl = live_intra_pnl + live_daily_pnl
            paper_pnl = paper_df["PnL"].sum() if not paper_df.empty else 0

            return {
                "Live Intra": live_intra_pnl,
                "Live Daily": live_daily_pnl,
                "Total Live PnL": total_live_pnl,
                "Paper": paper_pnl,
                "Last Update": f"{last_update_date} {last_update_time}",
                "INTRA Baskets": intra_df,
                "DAILY Baskets": daily_df,
                "PAPER Baskets": paper_df
            }

        except Exception as e:
            st.error(f"Error processing data: {e}")
            return None

def display_pnl_metrics(results):
    """Display PnL metrics in styled cards"""
    if not results:
        return
    
    # Create columns for metrics
    col1, col2, col3, col4 = st.columns(4)
    
    # Custom CSS for metrics
    st.markdown("""
    <style>
    .metric-card {
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        background-color: #f8f9fa;
        margin-bottom: 20px;
    }
    .metric-title {
        font-size: 16px;
        color: #6c757d;
        margin-bottom: 5px;
    }
    .metric-value {
        font-size: 24px;
        font-weight: bold;
    }
    </style>
    """, unsafe_allow_html=True)
    
    def get_pnl_color(value):
        return "color: green;" if value > 0 else "color: red;" if value < 0 else "color: gray;"
    
    with col1:
        st.markdown(f"""
        <div class="metric-card">
            <div class="metric-title">ðŸ“Š Total HTTS PnL</div>
            <div class="metric-value" style="{get_pnl_color(results['Total Live PnL'])}">
                {results['Total Live PnL']:,.2f}
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="metric-card">
            <div class="metric-title">ðŸ“Š HTTS INTRA PnL</div>
            <div class="metric-value" style="{get_pnl_color(results['Live Intra'])}">
                {results['Live Intra']:,.2f}
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div class="metric-card">
            <div class="metric-title">ðŸ“Š HTTS DAILY PnL</div>
            <div class="metric-value" style="{get_pnl_color(results['Live Daily'])}">
                {results['Live Daily']:,.2f}
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div class="metric-card">
            <div class="metric-title">ðŸ“Š HTTS PAPER PnL</div>
            <div class="metric-value" style="{get_pnl_color(results['Paper'])}">
                {results['Paper']:,.2f}
            </div>
        </div>
        """, unsafe_allow_html=True)

def display_basket_tables(results):
    """Display basket tables in a tabbed layout"""
    if not results:
        return
    
    tab1, tab2, tab3 = st.tabs(["INTRA Baskets", "DAILY Baskets", "PAPER Baskets"])
    
    def style_basket_table(df):
        """Apply styling to basket table"""
        if df.empty:
            return df
        
        df = df.sort_values(by='PnL', ascending=False).drop(columns=['Category']).reset_index(drop=True)
        df['PnL'] = df['PnL'].apply(lambda x: f"{x:,.2f}")
        return df
    
    with tab1:
        intra_df = style_basket_table(results['INTRA Baskets'])
        if not intra_df.empty:
            st.dataframe(intra_df, use_container_width=True, hide_index=True)
        else:
            st.info("No INTRA baskets available.")
    
    with tab2:
        daily_df = style_basket_table(results['DAILY Baskets'])
        if not daily_df.empty:
            st.dataframe(daily_df, use_container_width=True, hide_index=True)
        else:
            st.info("No DAILY baskets available.")
    
    with tab3:
        paper_df = style_basket_table(results['PAPER Baskets'])
        if not paper_df.empty:
            st.dataframe(paper_df, use_container_width=True, hide_index=True)
        else:
            st.info("No PAPER baskets available.")

def main():
    # Configure page
    st.set_page_config(
        page_title="HTTS Live PnL Dashboard", 
        page_icon="ðŸ“Š", 
        layout="wide",
        initial_sidebar_state="collapsed"
    )
    
    # Custom CSS for the entire app
    st.markdown("""
    <style>
    /* Main content area */
    .stApp {
        background-color: #f5f5f5;
    }
    /* Headers */
    h1, h2, h3, h4, h5, h6 {
        color: #2c3e50;
    }
    /* Dataframes */
    .dataframe {
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    /* Refresh indicator */
    .refresh-indicator {
        font-size: 14px;
        color: #6c757d;
        margin-top: 10px;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Title and description
    st.title("ðŸ“Š HTTS Live PnL Dashboard")
    st.markdown("""
    Real-time Profit and Loss monitoring for HTTS trading baskets. 
    Data refreshes automatically every 30 seconds.
    """)
    
    # Database connection details
    host = st.secrets.get("credentials", {}).get("DB_HOST", "")
    username = st.secrets.get("credentials", {}).get("DB_USERNAME", "")
    password = st.secrets.get("credentials", {}).get("DB_PASSWORD", "")
    database = st.secrets.get("credentials", {}).get("DB_DATABASE", "")
    
    # Initialize BasketExplorer
    explorer = BasketExplorer(host, username, password, database)
    
    # Create a placeholder for the dashboard content
    dashboard_placeholder = st.empty()
    
    # Auto-refresh logic
    refresh_interval = 30  # seconds
    last_refresh = st.empty()
    
    while True:
        # Get current time for refresh indicator
        current_time = datetime.now().strftime("%H:%M:%S")
        
        # Process data and display
        with dashboard_placeholder.container():
            results = explorer.process_data()
            
            if results:
                # Display metrics
                display_pnl_metrics(results)
                
                # Display last update time
                last_update = pd.to_datetime(results["Last Update"])
                last_update_str = last_update.strftime("%d-%m-%Y, %H:%M:%S")
                
                st.divider()
                st.caption(f"ðŸ“… Last data update: {last_update_str} | ðŸ•’ Dashboard refreshed: {current_time}")
                st.divider()
                
                # Display basket tables
                display_basket_tables(results)
        
        # Show refresh indicator
        last_refresh.caption(f"ðŸ”„ Next refresh in {refresh_interval} seconds...")
        
        # Wait for the refresh interval
        time.sleep(refresh_interval)

if __name__ == "__main__":
    main()
